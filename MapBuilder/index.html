<!DOCTYPE html>
<html>
    <head>
        <title>Map Builder</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
        <style>
            #map {
                display: grid;
                overflow: auto;
                background-color: lightgray;
                border: 1px solid lightgray;
                gap: 1px;
                position: relative;
            }
            .tile {
                background-color: aliceblue;
                cursor: pointer;
            }
            .tile:hover {
                border: 2px solid red;
            }
            .draggable-tile {
                cursor: pointer;
                width: 50px;
                height: 50px;
                -webkit-user-select: none !important;
                user-select: none !important; 
            }
            .draggable-tile.selected {
                border: 2px solid red;
            } 
            .draggable-tile:hover {
                border: 2px solid red;
            }
            .mapRender {
                display: flex;
                flex-direction: column;
                align-items: center;
                position: relative;
                overflow: auto; 
                width: 100%;
                cursor: grab;
            }
            .mapRender.dragging {
                cursor: grabbing;
            }
        </style>
    </head>
    <body>
        <div class="col-lg-10 mx-auto p-3 py-md-5">
            <div class="mb-3 card">  
                <div class="card-header">
                    <b>Configure map builder</b>
                </div>
                <div class="p-3">
                    <div class="mb-3 row">
                        <div class="col">
                            <label class="form-label">Map dimensions</label> 
                            <div class="row">
                                <div class="col">
                                    <input type="number" value="50" class="form-control" id="mapWidth" placeholder="Width">
                                </div>
                                <div class="col">
                                    <input type="number" value="50" class="form-control" id="mapHeight" placeholder="Height">
                                </div>
                            </div>
                        </div>        
                        <div class="col">
                            <label class="form-label">Upload tilemap</label>
                            <input type="file" id="tilemapInput" class="form-control" accept="image/png">
                        </div>
                        <div class="row col">
                            <div class="col">
                                <label class="form-label">Tile size (Pixels)</label> 
                                <input type="number" value="16" id="tileSize" class="form-control">
                            </div>
                            <div class="col">
                                <label class="form-label">Gap (Pixels)</label> 
                                <input type="number" value="1" id="gapSize" class="form-control">
                            </div>
                        </div>
                    </div>
                    <div>
                        <button class="btn btn-primary" id="configureMap">Configure</button>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="col-lg-4">
                    <div class="card mb-3">       
                        <div class="card-header">
                            <b>Available tiles</b>
                        </div>
                        <div id="tiles" class="p-3 d-flex flex-wrap gap-1">
                        </div>
                    </div>      
                    <div class="card">       
                        <div class="card-header">
                            <b>Import/Export</b>
                        </div>
                        <div class="p-3 d-flex flex-wrap gap-1">
                        
                        </div>
                    </div>
                </div>
                <div class="col-lg-8">
                    <div id="mapWrapper" class="card" style="display: none; position: relative;">
                        <div class="card-header">
                            <button id="fillMap" class="btn btn-primary btn-sm">Fill with currently selected</button>
                            <button id="undoButton" class="btn btn-secondary btn-sm">Undo</button>
                            <button id="resetZoom" class="btn btn-secondary btn-sm">Reset zoom</button>

                            <div style="float: right;">
                                <span>Current layer: <span id="layerDisplay"></span></span>&nbsp;
                                <button id="downLayer" class="btn btn-secondary btn-sm">Down</button>
                                <button id="upLayer" class="btn btn-secondary btn-sm">Up</button>
                            </div>
                        </div>
                        <div class="p-3 mapRender">
                            <div id="map" style="display: grid;">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </body>

    <script>
        let currentLayer = 0;
        let maxLayers = 10;
        let selectedTile = null;
        let isMouseDown = false;
        let mapTiles = [];
        let historyStack = [];

        function initializeMap(cols, rows) {
            mapTiles = Array.from({ length: maxLayers + 1 }, () => 
                Array.from({ length: rows }, () => Array(cols).fill(null))
            );
        }

        document.getElementById('configureMap').addEventListener('click', function() {
            const map = document.getElementById('map');
            const tileSize = parseInt(document.getElementById('tileSize').value) || 0;
            const gapSize = parseInt(document.getElementById('gapSize').value) || 0;
            const cols = parseInt(document.getElementById('mapWidth').value) || 0;
            const rows = parseInt(document.getElementById('mapHeight').value) || 0;
            const file = document.getElementById('tilemapInput').files[0] || null;

            if (!file) {
                alert('Please select a file');
                return;
            }

            configureTiles(file);
            initializeMap(cols, rows);

            map.innerHTML = '';
            map.style.gridTemplateColumns = `repeat(${cols}, ${tileSize + 1}px)`;

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {     
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.dataset.x = j;
                    tile.dataset.y = i;
                    tile.style.width = `${tileSize}px`;
                    tile.style.height = `${tileSize}px`;
                    tile.addEventListener('click', function() {
                        if (selectedTile && mapTiles[currentLayer][i][j]?.name !== selectedTile?.name) {
                            mapTiles[currentLayer][i][j] = selectedTile;
                            renderLayerTiles();
                            saveMapState();
                        }
                    });
                    map.appendChild(tile);
                }
            }

            //Handle mouse drag to place selected tile
            map.addEventListener('mousedown', function (e) {
                const tile = e.target;
                if (tile.classList.contains('tile')) {
                    isMouseDown = true;
                    placeTile(e);
                }
            });

            map.addEventListener('mousemove', function (e) {
                const tile = e.target;
                if (isMouseDown && selectedTile && tile.classList.contains('tile')) {
                    placeTile(e);
                }
            });

            map.addEventListener('mouseup', function () {
                if (isMouseDown) {
                    isMouseDown = false;
                    saveMapState();
                }
            });

            map.addEventListener('mouseleave', function () {
                // Reset the state if the mouse leaves the map area while dragging
                if (isMouseDown) {
                    isMouseDown = false;
                    saveMapState();
                }
            });

            function placeTile(e) {
                const tile = e.target;
                if (tile.classList.contains('tile') && selectedTile && tile.dataset.tile !== selectedTile.name) {
                    mapTiles[currentLayer][tile.dataset.y][tile.dataset.x] = selectedTile;
                    renderLayerTiles();
                }
            }

            saveMapState();
            updateLayer();
            document.getElementById('mapWrapper').style.display = 'block';
        });

        function configureTiles(file) {
            if (!file) return;

            const tileSize = parseInt(document.getElementById('tileSize').value) || 16;
            const gapSize = parseInt(document.getElementById('gapSize').value) || 0;   
            const tilesContainer = document.getElementById('tiles');

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.src = e.target.result;

                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    const tiles = [];

                    canvas.width = img.width;
                    canvas.height = img.height;
                    context.drawImage(img, 0, 0);

                    const rows = Math.ceil(img.height / (tileSize + gapSize));
                    const cols = Math.ceil(img.width / (tileSize + gapSize));

                    tilesContainer.innerHTML = '';
                    tilesContainer.style.display = 'grid';
                    tilesContainer.style.gridTemplateColumns = `repeat(auto-fill, ${tileSize}px)`;
                    tilesContainer.style.gridGap = `1px`;

                    for (let y = 0; y < rows; y++) {
                        for (let x = 0; x < cols; x++) {
                            const tileCanvas = document.createElement('canvas');
                            const tileContext = tileCanvas.getContext('2d');

                            tileCanvas.width = tileSize;
                            tileCanvas.height = tileSize;

                            tileContext.drawImage(
                                canvas,
                                x * (tileSize + gapSize),
                                y * (tileSize + gapSize),
                                tileSize,
                                tileSize,
                                0,
                                0,
                                tileSize,
                                tileSize
                            );

                            const tileDataURL = tileCanvas.toDataURL();
                            tiles.push(tileDataURL);

                            const tileImg = document.createElement('img');
                            const tileName = `tile_${x}_${y}`;
                            tileImg.className = 'draggable-tile';
                            tileImg.src = tileDataURL;
                            tileImg.dataset.name = tileName;
                            tileImg.style.width = `${tileSize}px`;
                            tileImg.style.height = `${tileSize}px`;

                            tileImg.addEventListener('click', function() {
                                selectedTile = {
                                    url: tileDataURL,
                                    name: tileName
                                };
                                const allTiles = document.querySelectorAll('.draggable-tile');
                                allTiles.forEach(img => img.classList.remove('selected'));
                                tileImg.classList.add('selected');
                            });

                            tilesContainer.appendChild(tileImg);
                        }
                    }
                };
            };

            reader.readAsDataURL(file);
        }

        document.getElementById('upLayer').addEventListener('click', function() {
            if (currentLayer == maxLayers) return;
            currentLayer += 1;
            updateLayer();
        });

        document.getElementById('downLayer').addEventListener('click', function() {
            if (currentLayer == 0) return;
            currentLayer -= 1;
            updateLayer();
        });

        function updateLayer() {
            const display = document.getElementById('layerDisplay');
            display.innerHTML = currentLayer;
            renderLayerTiles();
        }

        function renderLayerTiles() {
            const map = document.getElementById('map');
            const tiles = document.getElementsByClassName('tile');
            const tileSize = parseInt(document.getElementById('tileSize').value) || 0;
            const cols = parseInt(document.getElementById('mapWidth').value) || 0;

            mapTiles[currentLayer].forEach((row, rowIndex) => {
                row.forEach((tile, colIndex) => {
                    const tileIndex = rowIndex * cols + colIndex;
                    const tileCell = tiles[tileIndex];

                    if (tileCell) {
                        tileCell.style.backgroundImage = `url(${tile?.url || ''})`;
                        tileCell.dataset.tile = tile?.name || '';
                        tileCell.style.backgroundSize = `${tileSize}px ${tileSize}px`;
                    }
                });
            });
        }

        document.getElementById('fillMap').addEventListener('click', function() {
            const tiles = document.getElementsByClassName('tile');
            const cols = parseInt(document.getElementById('mapWidth').value) || 0;
            const rows = parseInt(document.getElementById('mapHeight').value) || 0;

            if (selectedTile) {
                let makeUpdate = false;
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) { 
                        if (mapTiles[currentLayer][i][j]?.name == selectedTile?.name) continue;
                        mapTiles[currentLayer][i][j] = selectedTile;
                        makeUpdate = true;
                    }
                }
                renderLayerTiles();
                if (makeUpdate) saveMapState();
            }
        });

        document.getElementById('undoButton').addEventListener('click', function() {
            if (historyStack.length > 0) {
                historyStack.pop();
                const previousState = historyStack[historyStack.length - 1];
                if (previousState) {
                    restoreMapState(previousState);
                }
                if (historyStack.length === 0) {
                    saveMapState();
                }
            }
        });

        function saveMapState() {
            const currentState = mapTiles.map(layer => 
                layer.map(row => row.slice()) 
            );
            historyStack.push(currentState);
        }

        function restoreMapState(state) {
            mapTiles = state.map(layer => 
                layer.map(row => row.slice()) 
            );
            renderLayerTiles();
        }

        let zoomLevel = 1;
        const zoomStep = 0.1;
        const zoomMin = 0.5;
        const zoomMax = 3;

        const map = document.getElementById('map');
        const mapRender = document.querySelector('.mapRender');

        function updateZoom(focusX, focusY, deltaZoom) {
            const prevZoomLevel = zoomLevel;
            zoomLevel = Math.min(Math.max(zoomLevel + deltaZoom, zoomMin), zoomMax);

            const zoomRatio = zoomLevel / prevZoomLevel;

            const rect = map.getBoundingClientRect();
            const offsetX = focusX - rect.left;
            const offsetY = focusY - rect.top;

            const currentTransform = getComputedStyle(map).transform;
            const matrix = currentTransform === "none" ? [1, 0, 0, 1, 0, 0] : currentTransform.match(/matrix.*\((.+)\)/)[1].split(', ').map(Number);

            const translateX = matrix[4];
            const translateY = matrix[5];

            const newTranslateX = offsetX - (offsetX - translateX) * zoomRatio;
            const newTranslateY = offsetY - (offsetY - translateY) * zoomRatio;

            map.style.transform = `scale(${zoomLevel}) translate(${newTranslateX / zoomLevel}px, ${newTranslateY / zoomLevel}px)`;
        }

        mapRender.addEventListener('wheel', (e) => {
            e.preventDefault();
            const deltaZoom = e.deltaY < 0 ? zoomStep : -zoomStep;
            updateZoom(e.clientX, e.clientY, deltaZoom);
        });

        document.getElementById('resetZoom').addEventListener('click', () => {
            zoomLevel = 1;
            currentTranslateX = 0;
            currentTranslateY = 0;
            map.style.transform = `scale(${zoomLevel}) translate(0px, 0px)`;
        });
    </script>
</html>